<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Akane&#39;s Dreamland</title>
  
  
  <link href="https://akaneym.com/atom.xml" rel="self"/>
  
  <link href="https://akaneym.com/"/>
  <updated>2023-01-05T14:18:00.000Z</updated>
  <id>https://akaneym.com/</id>
  
  <author>
    <name>rimwindy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 Spring 解析自定义命名空间</title>
    <link href="https://akaneym.com/posts/spring-parsing-custom-namespace/"/>
    <id>https://akaneym.com/posts/spring-parsing-custom-namespace/</id>
    <published>2023-01-05T14:18:00.000Z</published>
    <updated>2023-01-05T14:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近复习 Spring 的 IoC 容器时有些好奇 XML 配置文件及其各个标签的解析方式，毕竟分别使用 <code>bean</code> 标签将 Class 注入 IoC 容器还是最开始学习 Spring 时才使用过的方式，日常工作中基本都是使用注解来完成自动注入，因此对于 XML 文件内的一些细节倒是知之甚少。恰逢假期闲来无事，在经过一番搜索与学习之后算是有了些许收获，故此记录一篇，以便日后查阅。</p><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>在说明配置文件的解析之前，我们得先了解一下 Spring Bean 实例化的基本流程，毕竟配置文件是为了让 IoC 容器管理 Bean 对象而存在的。实例化流程中的细节还是非常多的，光是 Bean 的生命周期就足够我们喝上一壶的了，因此这里只介绍一下大体流程，重点只关注 XML 解析的部分。</p><p>对于配置文件的方式，Spring 提供了一个 <code>BeanDefinitionReader</code> 接口，不同的配置文件类型会由不同的实现类去解析，如 XML 配置文件会由 <code>XMLBeanDefinitionReader</code> 来解析，而 Groovy 配置文件则会由 <code>GroovyBeanDefinitionReader</code> 来解析。如果是使用注解的方式，则有一个专门的类—— <code>AnnotatedBeanDefinitionReader</code> 来解析。不过无论是使用配置文件（XML、Properties、Groovy…）还是注解的方式，都是殊途同归，它们的区别也只有入口不同，最终各自的 <code>BeanDefinitionReader</code> 都会将配置信息中的元数据转储为 BeanDefinition，继而存放至 BeanDefinitionMap 中。Spring 的上下文会在合适的时机遍历 Map 中所有的 BeanDefinition 并通过反射为其创建实例对象，最后将实例化完成后的 Bean 存放进 IoC 容器中，接受 Spring 的管理。这里我们需要关注的便是从 <code>XMLBeanDefinitionReader</code> 解析 XML 配置文件开始，直到 XML 中的元数据被转储为 BeanDefinition 并存放至 BeanDefinitionMap 中的过程。</p><h3 id="详细代码"><a href="#详细代码" class="headerlink" title="详细代码"></a>详细代码</h3><p>接下来，我们就根据上面的流程跟踪一下 Spring 的源代码，了解其中的一些实现细节。</p><p>因为我们使用的是 XML 配置的方式，因此首先找到入口类 <code>ClassPathXmlApplicationContext</code>，在其构造方法中有一个 <code>refresh()</code> 方法，这便是 Spring 容器的入口方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="built_in">this</span>.refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>refresh()</code> 方法中又执行了 <code>obtainFreshBeanFactory()</code> 方法，之后又经过 <code>refreshBeanFactory()</code> -&gt; <code>loadBeanDefinitions()</code> -&gt; <code>doLoadBeanDefinitions()</code> -&gt; <code>registerBeanDefinitions()</code> -&gt; <code>doRegisterBeanDefinitions()</code> 的流程后来到了 <code>parseBeanDefinitions()</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">               <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">               <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                   <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element)node;</span><br><span class="line">                   <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                       <span class="built_in">this</span>.parseDefaultElement(ele, delegate);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       delegate.parseCustomElement(ele);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           delegate.parseCustomElement(root);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，XML 中的标签会被分为两类加以解析，即代码中的 <code>DefaultNamespace</code> 和 <code>CustomElement</code>。前者是对 <code>http://www.springframework.org/schema/beans</code> 命名空间下四个默认标签—— <code>import</code>、<code>alias</code>、<code>bean</code> 和 <code>beans</code> 的解析，后者便是对自定义命名空间下标签的解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;import&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.importBeanDefinitionResource(ele);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;alias&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.processAliasRegistration(ele);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;bean&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">&quot;beans&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> <span class="built_in">this</span>.getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到自定义命名空间的解析过程分为两步，先是通过 <code>namespaceUri</code> 获取对应的 <code>NamespaceHandler</code>，再调用对应 Handler 的 <code>parse()</code> 方法进行解析。我们先来看看通过 <code>namespaceUri</code> 是如何获取到 <code>NamespaceHandler</code> 的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultNamespaceHandlerResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>((ClassLoader)<span class="literal">null</span>, <span class="string">&quot;META-INF/spring.handlers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultNamespaceHandlerResolver</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(classLoader, <span class="string">&quot;META-INF/spring.handlers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultNamespaceHandlerResolver</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader, String handlerMappingsLocation)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.logger = LogFactory.getLog(<span class="built_in">this</span>.getClass());</span><br><span class="line">    Assert.notNull(handlerMappingsLocation, <span class="string">&quot;Handler mappings location must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.classLoader = classLoader != <span class="literal">null</span> ? classLoader : ClassUtils.getDefaultClassLoader();</span><br><span class="line">    <span class="built_in">this</span>.handlerMappingsLocation = handlerMappingsLocation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> NamespaceHandler <span class="title function_">resolve</span><span class="params">(String namespaceUri)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = <span class="built_in">this</span>.getHandlerMappings();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">handlerOrClassName</span> <span class="operator">=</span> handlerMappings.get(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handlerOrClassName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">        <span class="keyword">return</span> (NamespaceHandler)handlerOrClassName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> (String)handlerOrClassName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="built_in">this</span>.classLoader);</span><br><span class="line">            <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Class [&quot;</span> + className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;] does not implement the [&quot;</span> + NamespaceHandler.class.getName() + <span class="string">&quot;] interface&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">NamespaceHandler</span> <span class="variable">namespaceHandler</span> <span class="operator">=</span> (NamespaceHandler)BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">                namespaceHandler.init();</span><br><span class="line">                handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">                <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Could not find NamespaceHandler class [&quot;</span> + className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, var7);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LinkageError var8) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Unresolvable class definition for NamespaceHandler class [&quot;</span> + className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, var8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getHandlerMappings</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line">    <span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line">            <span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Loading NamespaceHandler mappings from [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span> PropertiesLoaderUtils.loadAllProperties(<span class="built_in">this</span>.handlerMappingsLocation, <span class="built_in">this</span>.classLoader);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.logger.trace(<span class="string">&quot;Loaded NamespaceHandler mappings: &quot;</span> + mappings);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    handlerMappings = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(mappings.size());</span><br><span class="line">                    CollectionUtils.mergePropertiesIntoMap(mappings, (Map)handlerMappings);</span><br><span class="line">                    <span class="built_in">this</span>.handlerMappings = (Map)handlerMappings;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unable to load NamespaceHandler mappings from location [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>, var5);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (Map)handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>DefaultNamespaceHandlerResolver</code> 类中维护了一个名为 <code>handlerMappings</code> 的 Map，其内容是根据一个 Properties 配置文件生成的，这个文件的路径已经在该类的构造方法中固定下来了，即 <code>classpath:META-INF/spring.handlers</code>。可见 XML 中的 <code>namespaceUri</code> 只是一个 key，最终 Spring 会用这个 key 去 spring.handlers 文件中寻找对应的 value，从而拿到 <code>namespaceUri</code> 对应的解析器。我们可以看一下 spring-context.jar 对应目录下的 spring.handlers，差不多长这样:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http\://www.springframework.org/schema/context</span>=<span class="string">org.springframework.context.config.ContextNamespaceHandler</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/jee</span>=<span class="string">org.springframework.ejb.config.JeeNamespaceHandler</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/lang</span>=<span class="string">org.springframework.scripting.config.LangNamespaceHandler</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/task</span>=<span class="string">org.springframework.scheduling.config.TaskNamespaceHandler</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/cache</span>=<span class="string">org.springframework.cache.config.CacheNamespaceHandler</span></span><br></pre></td></tr></table></figure><p>另外，你应该还可以在同级目录下看到一个 spring.schemas 文件，这里面定义了 XSD 文件逻辑地址与物理地址的对应关系。前者便是我们在 XML 文件的 <code>schemaLocation</code> 部分填写的链接，而后者则是前者所对应的文件在本地存在的位置。为了避免 Spring 每次解析 XML 都需要去逻辑地址标注的网络上寻找 XSD 文件，一般都推荐在 Properties 文件中定义好两者的映射关系，详见 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core.appendix.xsd-custom-registration-spring-schemas">Spring 官方文档</a>的解释。如果你也对 XML 知之不详，可能会好奇这个文件的作用，它是 XML Schema 的定义文件，用于描述 XML 的结构，它规定了你的 XML 文件中可以出现哪些元素以及它们的格式是怎样的。详细的说明可以查看 <a href="https://www.w3schools.com/xml/schema_intro.asp">W3Schools 的教程</a>。它不仅在解析的时候需要用到，IDE 一般也会通过该文件来完成编写 XML 文件时的 Auto Suggestion &amp; Completion。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-2.5.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-3.0.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-3.1.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-3.2.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-4.0.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-4.1.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-4.2.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context-4.3.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br><span class="line"><span class="attr">http\://www.springframework.org/schema/context/spring-context.xsd</span>=<span class="string">org/springframework/context/config/spring-context.xsd</span></span><br></pre></td></tr></table></figure><p>说回上文，拿到 <code>NamespaceHandler</code> 后再来看它的 <code>parse()</code> 方法，其实现类为 <code>NamespaceHandlerSupport</code>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="built_in">this</span>.findParserForElement(element, parserContext);</span><br><span class="line">    <span class="keyword">return</span> parser != <span class="literal">null</span> ? parser.parse(element, parserContext) : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是通过当前命名空间下 XML 标签的名字找到对应的 <code>BeanDefinitionParser</code>，再调用对应的 <code>parse()</code> 方法。比如我们常见的 <code>&lt;context:component-scan&gt;</code>，它属于 <code>context</code> 命名空间，根据 spring.handlers 文件中的配置信息可以得知其对应的 <code>NamespaceHandler</code> 为 <code>ContextNamespaceHandler</code>，我们不妨看看这个 Handler 内是怎么写的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ContextNamespaceHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;property-placeholder&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertyPlaceholderBeanDefinitionParser</span>());</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;property-override&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertyOverrideBeanDefinitionParser</span>());</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;annotation-config&quot;</span>, <span class="keyword">new</span> <span class="title class_">AnnotationConfigBeanDefinitionParser</span>());</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;component-scan&quot;</span>, <span class="keyword">new</span> <span class="title class_">ComponentScanBeanDefinitionParser</span>());</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;load-time-weaver&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoadTimeWeaverBeanDefinitionParser</span>());</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> <span class="title class_">SpringConfiguredBeanDefinitionParser</span>());</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;mbean-export&quot;</span>, <span class="keyword">new</span> <span class="title class_">MBeanExportBeanDefinitionParser</span>());</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;mbean-server&quot;</span>, <span class="keyword">new</span> <span class="title class_">MBeanServerBeanDefinitionParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>ContextNamespaceHandler</code> 的 <code>init()</code> 方法中注册了标签名与 <code>BeanDefinitionParser</code> 的映射关系，因此 <code>NamespaceHandlerSupport</code> 才能根据不同的标签名调用不同的 <code>parse()</code> 方法。还是上面的例子，我们看看 <code>ComponentScanBeanDefinitionParser</code> 的 <code>parse()</code> 方法是怎么写的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> element.getAttribute(<span class="string">&quot;base-package&quot;</span>);</span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, <span class="string">&quot;,; \t\n&quot;</span>);</span><br><span class="line">    <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="built_in">this</span>.configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    <span class="built_in">this</span>.registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容并不复杂，只是使用 <code>ClassPathBeanDefinitionScanner</code> 扫描 XML 中配置的 <code>base-package</code> 路径，最后将该路径下的所有类转储为 BeanDefinition 并注册进 BeanDefinitionMap 中，Spring 会根据 Map 中的 Bean 信息在后续的流程中逐个实例化这些 Bean。</p><p>看到这里，XML 配置文件的解析部分就已经结束了，其实主要就是依靠 <code>NamespaceHandler</code> 及其各个子标签的 <code>BeanDefinitionParser</code> 来完成的，中间用到了两个之前没听说过的配置文件，感觉又多了点<del>有用的</del>知识!</p><h2 id="DIY-一个简单的自定义标签"><a href="#DIY-一个简单的自定义标签" class="headerlink" title="DIY 一个简单的自定义标签"></a>DIY 一个简单的自定义标签</h2><p>有了上面的理论基础，我们便可以尝试着实现一个自定义命名空间下的标签了。比如我想实现这样一个标签，它的作用是在每个 Bean 注入到 Spring 容器前打印当前 Bean 的属性信息。功能很简单，实现起来也不难，大概就是以下几步:</p><ol><li>确定自定义命名空间、XML 标签及 XSD 文件的名称</li><li>编写 XSD 文件</li><li>编写 spring.handlers 及 spring.schemas 文件</li><li>实现自定义的 NamespaceHandler</li><li>实现自定义的 BeanDefinitionParser</li><li>实现自定义的 BeanPostProcessor</li></ol><p>其中前五步是通用操作，最后一步是为了完成本例的需求而创建的。实现了 <code>BeanPostProcessor</code> 接口的类可以选择实现 <code>postProcessBeforeInitialization()</code> 或者 <code>postProcessAfterInitialization()</code> 方法，它们会在每个 Bean 的生命周期中被调用。在本例中这两个方法都可以实现需求，这里我选择在 <code>postProcessAfterInitialization()</code> 方法中打印当前类的信息。</p><h3 id="确定自定义命名空间、XML-标签及-XSD-文件的名称"><a href="#确定自定义命名空间、XML-标签及-XSD-文件的名称" class="headerlink" title="确定自定义命名空间、XML 标签及 XSD 文件的名称"></a>确定自定义命名空间、XML 标签及 XSD 文件的名称</h3><p>这里就以我的域名为例:</p><ul><li>XML Namespace: <code>https://akaneym.com/schema/akane</code></li><li>XML Tag: <code>&lt;akane:logBeanInfo/&gt;</code></li><li>XSD File: <code>https://akaneym.com/schema/akane/beans.xsd</code></li></ul><h3 id="编写-XSD-文件"><a href="#编写-XSD-文件" class="headerlink" title="编写 XSD 文件"></a>编写 XSD 文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- beans.xsd (inside package classpath:com/akaneym/config) --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://akaneym.com/schema/akane&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetNamespace</span>=<span class="string">&quot;https://akaneym.com/schema/akane&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;logBeanInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编写-spring-handlers-及-spring-schemas-文件"><a href="#编写-spring-handlers-及-spring-schemas-文件" class="headerlink" title="编写 spring.handlers 及 spring.schemas 文件"></a>编写 spring.handlers 及 spring.schemas 文件</h3><p>这里只需要注意一点，因为 Properties 文件中 <code>:</code> 也算分隔符，因此需要转义一下。</p><h4 id="META-INF-spring-handlers"><a href="#META-INF-spring-handlers" class="headerlink" title="META-INF/spring.handlers"></a>META-INF/spring.handlers</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">https\://akaneym.com/schema/akane</span>=<span class="string">com.akaneym.handler.AkaneNamespaceHandler</span></span><br></pre></td></tr></table></figure><h4 id="META-INF-spring-schemas"><a href="#META-INF-spring-schemas" class="headerlink" title="META-INF/spring.schemas"></a>META-INF/spring.schemas</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">https\://akaneym.com/schema/akane/beans.xsd</span>=<span class="string">com/akaneym/config/beans.xsd</span></span><br></pre></td></tr></table></figure><h3 id="实现自定义的-NamespaceHandler"><a href="#实现自定义的-NamespaceHandler" class="headerlink" title="实现自定义的 NamespaceHandler"></a>实现自定义的 NamespaceHandler</h3><p>AkaneNamespaceHandler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.akaneym.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.akaneym.parser.LogBeanInfoBeanDefinitionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shiro</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023-01-02 10:32 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AkaneNamespaceHandler</span> <span class="keyword">extends</span> <span class="title class_">NamespaceHandlerSupport</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitionParser(<span class="string">&quot;logBeanInfo&quot;</span>, <span class="keyword">new</span> <span class="title class_">LogBeanInfoBeanDefinitionParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现自定义的-BeanDefinitionParser"><a href="#实现自定义的-BeanDefinitionParser" class="headerlink" title="实现自定义的 BeanDefinitionParser"></a>实现自定义的 BeanDefinitionParser</h3><p>LogBeanInfoBeanDefinitionParser</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.akaneym.parser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.akaneym.processor.LogBeanInfoPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.BeanDefinitionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.ParserContext;</span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Element;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shiro</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023-01-02 10:37 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBeanInfoBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionParser</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClassName(LogBeanInfoPostProcessor.class.getName());</span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(<span class="string">&quot;LogBeanInfoPostProcessor&quot;</span>, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现自定义的-BeanPostProcessor"><a href="#实现自定义的-BeanPostProcessor" class="headerlink" title="实现自定义的 BeanPostProcessor"></a>实现自定义的 BeanPostProcessor</h3><p>LogBeanInfoPostProcessor</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.akaneym.processor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shiro</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023-01-02 10:42 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBeanInfoPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LogBeanInfo -&gt; &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Show-Time"><a href="#Show-Time" class="headerlink" title="Show Time!"></a>Show Time!</h3><p>先创建两个测试用的实体类:</p><h4 id="User"><a href="#User" class="headerlink" title="User"></a>User</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.akaneym.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shiro</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 11/1/2022 11:17 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.akaneym.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shiro</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 11/1/2022 11:18 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> Integer number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 applicationContext.xml 中将上面两个类注入 Spring 容器中并开启我们的自定义注解，别忘了添加 <code>xmlns</code> 和 <code>schemaLocation</code>:</p><h4 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:akane</span>=<span class="string">&quot;https://akaneym.com/schema/akane&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            https://akaneym.com/schema/akane https://akaneym.com/schema/akane/beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.akaneym.bean.Address&quot;</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;street&quot;</span> <span class="attr">value</span>=<span class="string">&quot;下北泽&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1024&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.akaneym.bean.User&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Guitar Hero&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">akane:logBeanInfo</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后编写一个测试方法，因为我们的需求是 Bean 进入容器之前打印 Bean 信息，因此只需要获取到 IoC 容器就可以看到效果了:</p><h4 id="JUnit-Test"><a href="#JUnit-Test" class="headerlink" title="JUnit Test"></a>JUnit Test</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beanConfigurationTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LogBeanInfo -&gt; Address&#123;street=&#x27;下北泽&#x27;, number=1024&#125;</span><br><span class="line">LogBeanInfo -&gt; User&#123;userName=&#x27;Guitar Hero&#x27;, address=Address&#123;street=&#x27;下北泽&#x27;, number=1024&#125;&#125;</span><br></pre></td></tr></table></figure><p>Nice！打完，收工！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近复习 Spring 的 IoC 容器时有些好奇 XML 配置文件及其各个标签的解析方式，毕竟分别使用 &lt;code&gt;bean&lt;/code&gt; 标签将 Class 注入 IoC 容器还是最开始学习 Spring 时才使用过的方式，日常工作中基本都是使用注解来完成自动注入，因此</summary>
      
    
    
    
    <category term="笔记本" scheme="https://akaneym.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="Spring" scheme="https://akaneym.com/tags/Spring/"/>
    
    <category term="Namespace" scheme="https://akaneym.com/tags/Namespace/"/>
    
  </entry>
  
  <entry>
    <title>2022 年终总结</title>
    <link href="https://akaneym.com/posts/summary-for-2022/"/>
    <id>https://akaneym.com/posts/summary-for-2022/</id>
    <published>2022-12-29T05:07:00.000Z</published>
    <updated>2022-12-29T05:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>岁聿其末，年关将至。大概是因为所谓的生活仪式感吧，每年这个时候，都会有想写点什么的冲动。今年发生了太多的事，思来想去，还是觉得应该写一篇留个纪念。</p><p>过去的 2022 年对很多人来说都是艰难的一年，持续反复的疫情影响了无数人的生活。</p><p>去年这个时候，国内的疫情控制的还不错，得益于动态清零的落实，只有跨省流动才需要做核酸，日常的工作生活基本没有受到疫情的影响。跨年的时候，还和大学同学简单聚了个餐，了解了下各自的近况。但随着春节将至，各地的感染人数日渐增多，政策也逐渐收紧，当时我便有种预感，今年可能没法回家过年了。事实也正是如此，一些地方先后提倡就地过年，而“恶意返乡”也是当时造出的词。</p><p>因为工作第一年没有年假，我一直到小年夜才放假。那会儿的政策是往返需要 48h 的核酸，并且年后回公司上班需要先居家隔离七天。这在现在来看可能也不算什么了，但在当时我还从未做过核酸，对此也比较抗拒。另外权衡了下路途中的感染风险以及年后隔离的多有不便，最终还是决定留在上海过年了。放假的那天，我走出公司大楼，暮色中只有零星的几个人，曾经热闹的街道在寒风中显得格外寂寥，只有元旦时挂在树上的彩灯增添了些许节日气氛。这座摩登的城市差不多也只有这几天才会显得安静一些。</p><p>过年的时候外卖基本没人送了，因此我早早的就买好了零食水果，为之后的宅家做准备。年前家里寄了些腊肠、狮子头、馒头等年货，加上住的地方也有厨房，因此吃饭倒不成问题。年三十的晚上是叔叔家的拜年祭陪我度过的，虽说这拜年祭一年不如一年，不过毕竟大过年的，虽然没有家人相伴，但看看带着年味儿的直播，倒也还算热闹。这其中我最喜欢的单品便是<a href="https://www.bilibili.com/festival/2022bnj?bvid=BV1Nu411d7Qh">《锦山城彩球花会异事》</a>了，吸引我的是流畅的打斗、可爱的角色和那首江湖题材的燃曲——《再会江湖》。当时我很意外国漫中还有这样的作品，带着好奇与期待，我点开了《风灵玉秀》的播放页面，此后几天便深深地沉浸在了那个快意恩仇的武侠世界中。客观来讲，《风灵玉秀》明显的问题并不少，包括剧情上的、作画上的等等，但瑕不掩瑜，我依然觉得这是一部值得推荐的好作品。当时正值动画第二部众筹，因为工作了有点小钱，就直接买了 All in 档的，但我没想到众筹的赠品陆陆续续直到七月份才全收到。本来一个快递可以发完，但不知道叔叔怎么搞的，所有的赠品都拆开到不同的箱子里分批邮寄，搞得我来来回回跑了好几趟，房间角落里摆了一堆粉色箱子，不知道的还以为我给叔叔送了多少钱。当然这都是后话了，关于这部作品我其实有很多想说的，不过这毕竟只是篇年终总结，详细的还是日后单开一篇来说比较好。</p><p>过年的假期里还发生了一件事——我开始看皮套人（虚拟主播）了。本来我对皮套人是嗤之以鼻的，不知道这有啥好看的。2D 的皮套人模型（大部分）不如动画好看，至于 3D 的，还不如 MMD 好看，至于直播内容——我此前除了偶尔看看游戏相关的，其他直播基本没看过。不过虽然一直没看，但毕竟常年冲浪在互联网的第一线，也算是个弄潮儿，因此 V 圈的瓜是一个也没少吃。V 圈的大姐二姐我也是门儿清，其他什么宇宙第一 V 猫雷（现已转生）、热水器塔菲、A-Soul 圣嘉然等等都算是如雷贯耳了。大概是在大年初二的晚上——也可能是初三，看着窗外的万家灯火，我孤身一人躺在出租屋里，不觉悲从中来，竟忍不住要落泪了（并没有）。就在这时，B 站首页给我推送了“阿梓从小就很可爱”的直播，当时我想着反正也是无聊，听别人唠唠嗑也是好的，顺便看看这皮套人直播到底有何精妙之处。没想到这一看就上头了，恕我言辞贫乏，难以准确形容当时的感觉，差不多就是“当你伤心的时候，耶和华怀抱你，如同牧人怀抱羊羔”一样的感觉吧。也正是在那之后，我渐渐明白了虚拟主播会有那么多受众的原因所在——陪伴。无论你身处何方，境况如何，她们都会准时在直播间出现，为大家带来欢乐。也正是如此，才会有“30岁，是小孩梓🤡”这样的人吧。虽然在那之后，我依然很少看直播，但我却为她们都点了关注。在某个失眠的深夜，打开手机，还能看见熟悉的她们，便又能安心睡去，一如看到灯塔的夜航船。</p><p>之后的事情大家都知道了，三月末上海就逐渐开始封城，直到六月才陆续解封。因为我早早的准备了一袋大米和若干挂面，所以我倒并不担心自己会饿死，但物资的匮乏还是给我上了一课。事实证明，当社会重大危机来临时，你只能靠自己提前准备，指望政府和社会的救济是天真的，这在最近全面放开后药品的短缺中也得到了体现。得益于平时就喜欢囤点东西的习惯，封城的两个多月里我的生活物资倒并不缺，主要还是食物。毕竟再怎么样，蔬菜水果也囤不了那么多。各大外送 APP 的店铺商家大部分都处于闭店状态，只有在特定的时间点才能去抢购，什么时候能买，能买到什么全凭运气。那时候是居家办公，我一有空就打开手机刷新，虽然大部分时候是无功而返，但偶尔能买到便能吃个好几天，也别管爱不爱吃了，能买到并且送到手上就已经很不错了，怎么说也能改善改善伙食。那段时间基本都是早饭不吃或者吃点面包加牛奶（看能不能买到），中午吃方便面，晚上吃鸡蛋挂面。本来我还挺爱吃面的，但这么吃下去终究还是腻了，以至于解封后到现在我都再没吃过面条。还好后来有了小区团购，物资渐渐没那么紧张了，虽然还是不能想吃啥买啥，但能买的东西还是挺多了，基本能覆盖到日常的生活，感谢我们小区的团长们！Lockdown 期间我的生活比较单调，基本就是白天居家办公，到饭点了就整点吃的，晚上打打游戏、看看书或者学点新技术。白天工作之余晒晒太阳，看看窗外的鸟雀，倒也还算惬意。那会儿经常有灰椋鸟飞到窗外的晾衣架上叽叽喳喳，对面的楼顶上也会有几只珠颈斑鸠晒太阳。也正是这个时候我对这些鸟类产生了兴趣，经过大半年在鸟吧的熏陶，现在对生活中常见的鸟也能认个七七八八了，算得上是半个“翼研丁真”了吧。</p><p>六月解封后生活又回到了正常的轨道上，总体而言有些乏善可陈。工作上和同事们更熟悉了，在新的项目中也学到了很多；生活上相比以往更规律了，最重要的还是心态上的变化，不再像刚毕业那会那么焦虑了。说到底还是对世界的认知更清晰了点，放弃了一些不切实际的幻想，学会享受每天细微的进步。心态放平后，也不再失眠了，也能看得进去一些杂书了。总的来说，我觉得这是一个不错的开始。</p><p>而对于未来的一年，我其实也有些规划。首先当然是多学些工作相关的技术栈，为之后的职业生涯打下更好的基础。另外就是把英语捡起来，虽说现在的英语看文档还行，但最近一年每天逛 reddit，还是会经常要查翻译。偶尔想看看英文的公开课，在无字幕的情况下还是有些困难，考虑到未来的发展机会，现在这点英语肯定是不够用的。最后就是重新整理下荒废已久的博客，尽量多写些内容，记录学习收获之余，还能提升下文字表达能力，感觉上了大学后，写文章的能力明显不如高中时候了。</p><p>写了这么多，看上去也都是些无关紧要的小事，不过也正是这些平淡的日常，构成了我的 2022。虽然不足挂齿，却也独此一份，我想这就是刘亮程所说的“今生今世的证据”吧。另外还是希望疫情能快点过去，世界能迎来真正的春暖花开。</p><p>最后，祝大家新年快乐！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;岁聿其末，年关将至。大概是因为所谓的生活仪式感吧，每年这个时候，都会有想写点什么的冲动。今年发生了太多的事，思来想去，还是觉得应该写一篇留个纪念。&lt;/p&gt;
&lt;p&gt;过去的 2022 年对很多人来说都是艰难的一年，持续反复的疫情影响了无数人的生活。&lt;/p&gt;
&lt;p&gt;去年这个时候，</summary>
      
    
    
    
    <category term="日常" scheme="https://akaneym.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="年终总结" scheme="https://akaneym.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 MySQL 手记</title>
    <link href="https://akaneym.com/posts/docker-with-mysql/"/>
    <id>https://akaneym.com/posts/docker-with-mysql/</id>
    <published>2019-12-11T07:15:00.000Z</published>
    <updated>2019-12-11T07:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 Go 语言编写，是目前最流行的容器解决方案。使用Docker可以将应用及依赖打包到一个可移植的容器中，然后发布到任何流行的 Windows 或 Linux 机器上运行。由于其完全使用沙盒机制，真正实现了应用程序与基础架构的分离，且与传统的虚拟机相比，Docker 的性能开销也极低。</p><blockquote><p><em>Debug your app, not your environment.</em></p></blockquote><h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 主要有三个重要的基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。</p><ul><li><p>镜像<br>Docker 镜像（Image）是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li><li><p>容器<br>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p></li><li><p>仓库<br>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，通常可以选择<a href="https://hub.docker.com/">Docker Hub</a>，如果有私有仓库的需要的话，可以选择使用官方提供的Docker Registry服务。</p></li></ul><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>因为最近学校开设了 JSP 的实验课，需要用到数据库服务，但是安装一个完整的数据库需要很大的硬盘空间（SQL Server 需要10G，下载还贼慢，真是醉了…），而且很多功能也用不上，所以我就选择了使用轻量化的 Docker 来运行 MySQL，下面记录一下具体操作：</p><h2 id="开启虚拟化"><a href="#开启虚拟化" class="headerlink" title="开启虚拟化"></a>开启虚拟化</h2><blockquote><p>如果是Windows的话，需要64位机器、Windows 10的系统，然后需要至少4G的内存，具体的安装要求可以参考<a href="https://docs.docker.com/docker-for-windows/install">官网</a>的介绍。</p></blockquote><p>首先需要查看计算机有没有开启虚拟化（如果你之前安装过手游模拟器的话，大概率会提示你开启VT的，这里的虚拟化就是指这个东西~），查看方法也非常简单，打开任务管理器的性能标签页即可查看。如果没有开启的话需要进BIOS开启一下，否则Docker无法使用。<br><img src="/img/2019/12/11/1.png" class="lazy" data-srcset="/img/2019/12/11/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="VT"></p><p>另外还需要 Hyper-V 的支持，不过 Docker 会自动帮我们开启，所以也不需要手动开启了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>去<a href="https://www.docker.com/">官网</a>下载安装包即可，安装完成后会提示重启，方便系统添加Docker需要的组件。</p><h2 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h2><p>重启完成后你应该就能在系统托盘上看到Docker的图标了，不过因为众所周知的原因，在国内拉取Docker Hub上的镜像速度不是很理想，因此可以选择国内的加速服务，比如我这里使用了网易的：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></p><p>选择Settings-Daemon-Registry mirrors，将镜像站点的链接粘贴进去即可：<br><img src="/img/2019/12/11/2.png" class="lazy" data-srcset="/img/2019/12/11/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="Registry mirrors"></p><p>配置完成后需要重新启动Docker生效。</p><h1 id="下载并运行MySQL镜像"><a href="#下载并运行MySQL镜像" class="headerlink" title="下载并运行MySQL镜像"></a>下载并运行MySQL镜像</h1><p>可以去Docker Hub搜索相应的镜像，也可以在terminal中使用docker search来搜索，比如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p><img src="/img/2019/12/11/3.png" class="lazy" data-srcset="/img/2019/12/11/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="docker search"></p><p>可以看到返回了镜像名称、镜像介绍、star数等信息，我们可以选择官方的镜像进行下载，使用如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以自定义拉取镜像的版本，默认为最新版本</span></span><br><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p>安装完成后可以使用docker images来查看已有的镜像：<br><img src="/img/2019/12/11/4.png" class="lazy" data-srcset="/img/2019/12/11/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="images"></p><p>使用如下命令启动MySQL镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name MySQL_Demo -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure><p>返回一串 CONTAINER ID，代表已经启动成功。接下来就可以使用IDE或Navicat等工具连接你的数据库了。<br><img src="/img/2019/12/11/5.png" class="lazy" data-srcset="/img/2019/12/11/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="docker run"></p><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="查看已运行的容器"><a href="#查看已运行的容器" class="headerlink" title="查看已运行的容器"></a>查看已运行的容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h2 id="进入mysql容器"><a href="#进入mysql容器" class="headerlink" title="进入mysql容器"></a>进入mysql容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it MySQL_Demo bash</span><br></pre></td></tr></table></figure><h2 id="启动、停止、杀死容器"><a href="#启动、停止、杀死容器" class="headerlink" title="启动、停止、杀死容器"></a>启动、停止、杀死容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start|stop|<span class="built_in">kill</span> Name/ID</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi Name/ID</span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> Name/ID</span><br></pre></td></tr></table></figure><p><em>E.N.D</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言编写，是目前最流行的容器解决方案。使用Docker可以将应用及依赖打包到一个可移植的容器中，然后发布到任何流行的 Windows 或 Linux 机器上运行。由于其完全使用沙盒机制，真正实现了应用程序与基础架构的分离，</summary>
      
    
    
    
    <category term="笔记本" scheme="https://akaneym.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="Docker" scheme="https://akaneym.com/tags/Docker/"/>
    
    <category term="MySQL" scheme="https://akaneym.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux安装指南</title>
    <link href="https://akaneym.com/posts/installation-guide-of-arch/"/>
    <id>https://akaneym.com/posts/installation-guide-of-arch/</id>
    <published>2019-11-11T03:41:00.000Z</published>
    <updated>2022-11-13T10:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-note blockquote-note__info"><div class="blockquote-note__header"><div class="blockquote-note__icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></div>Note</div><div class="blockquote-note__content"><p>本指南已过时，建议参考最新 Wiki 或其他博主的整理。如：</p><ul><li><a href="https://wiki.archlinux.org/title/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">ArchWiki - Installation guide</a></li><li><a href="https://arch.icekylin.online/">archlinux 简明指南</a></li></ul></div></blockquote><p>最近又换回Arch啦，听闻base软件包组已经被同名软件元包取缔（目前二者无法相互替代），所以安装过程又有变化了。鉴于自己也是经常需要找Wiki查看安装手册，也需要在安装后到处找配置相关的信息，甚感繁琐，故此写一篇比较完整的安装手记，方便日后使用。</p><blockquote><p>因为内容比较多，打算先写一个大致的框架，一些简单的操作和细节补充就先跳过了，等后续有时间再慢慢填坑吧~</p></blockquote><h1 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a><em>Preview</em></h1><p><img src="/img/2019/11/11/0.png" class="lazy" data-srcset="/img/2019/11/11/0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="dolphin"></p><p><img src="/img/2019/11/11/1.png" class="lazy" data-srcset="/img/2019/11/11/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="lockscreen"></p><p><img src="/img/2019/11/11/2.png" class="lazy" data-srcset="/img/2019/11/11/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="neofetch"></p><h1 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><p>可以去官方提供的下载处进行下载：<a href="https://www.archlinux.org/download">https://www.archlinux.org/download</a><br>目前提供的有BT种子和磁力链接，HTTP/HTTPS下载的话直接往下翻，找到中国的镜像站点进行下载就好了。下载完成后可以查看一下文件的散列值（另一种译名叫哈希）验证完整性，Windows上的工具也很多，如果你之前没有用过的话，也不必专门去下载了，可以使用自带的Power Shell来完成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Usage:</span></span><br><span class="line">Get-FileHash &lt;filepath&gt; -Algorithm MD5</span><br></pre></td></tr></table></figure><p>按照计算出的MD5值与官网给出的比对一下即可：<br><img src="/img/2019/11/11/3.png" class="lazy" data-srcset="/img/2019/11/11/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="MD5"></p><h2 id="确定启动类型"><a href="#确定启动类型" class="headerlink" title="确定启动类型"></a>确定启动类型</h2><blockquote><p>因为不同的启动模式安装方法会有少许的不同，所以需要特别注意一下。现在大多数都是UEFI的，所以MBR就先鸽了，之后再补充吧￣へ￣</p></blockquote><p>确定启动类型的方法有很多：</p><ul><li>可以按下win + r，在弹出的运行框中输入msinfo32，回车后会打开系统信息，在里面有一个BIOS模式，看看是不是UEFI模式（近几年比较新的电脑一般都是UEFI）。</li><li>也可以右键win徽标键，选择磁盘管理，看看你的C盘最前面有没有一个EFI分区，有的话就说明是UEFI启动模式。</li></ul><h2 id="准备好硬盘空间"><a href="#准备好硬盘空间" class="headerlink" title="准备好硬盘空间"></a>准备好硬盘空间</h2><p>当然要准备好一块硬盘空间才能安装我们的系统了，可以使用win自带的磁盘管理，也可以使用第三方的比如分区助手之类的工具，大小看自己喜欢吧。</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><p>准备好一个U盘，写入镜像可以使用rufus这款软件，官网在<a href="https://rufus.akeo.ie/">这里</a>。<br>设备里选择你的U盘（记得备份数据，U盘会被清空），接着选择镜像，下面选择启动类型，UEFI就选UEFI，不是的话就选第一个。下面的可以默认：<img src="/img/2019/11/11/4.png" class="lazy" data-srcset="/img/2019/11/11/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="rufus"></p><p>写入方式默认就好~<br><img src="/img/2019/11/11/5.png" class="lazy" data-srcset="/img/2019/11/11/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="rufus.png"></p><h1 id="安装ing"><a href="#安装ing" class="headerlink" title="安装ing"></a>安装ing</h1><h2 id="设置启动顺序"><a href="#设置启动顺序" class="headerlink" title="设置启动顺序"></a>设置启动顺序</h2><p>这一步因为不同的电脑进入BIOS的按键不一样，所以需要大家自己百度一下。比如我的联想拯救者，BIOS键就是F2，只需要在开机时出现logo时快速点按BIOS键就可以了。进入BIOS后找到boot栏，找到你的U盘，将其调整为第一启动项（就是位置放在最上面），然后保存退出即可，不出意外的话，再次启动就可以看到arch的安装界面了，选择第一项即可进入到Arch的live安装环境。</p><h2 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h2><h3 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h3><p>Arch的安装是需要联网的，所以需要保证网络畅通。如果是自动获取ip的有线网络（比如把电脑的网线直接插到路由器上），应该什么都不用做，测试一下网络吧：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p>如果输出一串64 bytes from xxx (xxx): icmp_seq=xxx tti=xxx time=xxxms的东西就表示联网成功了。<br>如果用的是WiFi的话，可以使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>接下来正常输入密码就可以使用了。</p><h3 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl set-ntp <span class="literal">true</span></span><br><span class="line"><span class="comment"># 正常情况下这条指令应该是没有输出的，所以可以使用下面的命令检查服务状态</span></span><br><span class="line">timedatectl status</span><br></pre></td></tr></table></figure><h3 id="查看硬盘分区"><a href="#查看硬盘分区" class="headerlink" title="查看硬盘分区"></a>查看硬盘分区</h3><p>这一步比较重要，建议大家一定要看清楚再格盘。<br>可以使用lsblk来查看硬盘状态（确定刚才分好的硬盘）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><p>就像这样：<br><img src="/img/2019/11/11/6.jpg" class="lazy" data-srcset="/img/2019/11/11/6.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="lsblk"></p><h3 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h3><p>当分区建立好了，这些分区都需要使用适当的文件系统进行格式化。举个例子，如果根分区在 /dev/sdX1 上并且会使用 ext4 文件系统，运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据上一步查看到的硬盘信息，将sdX1替换成你想要安装系统的磁盘号</span></span><br><span class="line">mkfs.ext4 /dev/sdX1</span><br></pre></td></tr></table></figure><h3 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h3><p>如果你是单独一个Arch系统的话，则还应该分出一个新的EFI分区，如果是Win + Arch双系统的话，则需要挂载你原来的EFI分区到Arch的EFI分区上。</p><p>执行以下命令将根分区挂载到/mnt：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将sdX1替换为之前创建的根分区</span></span><br><span class="line">mount /dev/sdX1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /mnt/boot</span><br><span class="line"><span class="comment"># sdX2是你的Win的EFI分区，一定要看清楚，一般大小在100M，200M左右。</span></span><br><span class="line">mount /dev/sdX2 /mnt/boot</span><br></pre></td></tr></table></figure><p>挂载完成后可以用lsblk命令查看有没有挂载成功。比如我的硬盘情况：<br><img src="/img/2019/11/11/7.jpg" class="lazy" data-srcset="/img/2019/11/11/7.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="mount"><br>sda是我的机械硬盘，sda1-3分别对应D、E、F分区，nvme0n1是我的固态硬盘，p1-p4几个分区分别对应我的EFI分区、MBR分区、Windows的C盘、Arch根分区。我没分swap分区，也没有单独分出home，大家按自己情况选择吧~（没有swap分区可能无法正常休眠）</p><h3 id="选择软件镜像库"><a href="#选择软件镜像库" class="headerlink" title="选择软件镜像库"></a>选择软件镜像库</h3><p>软件仓库是软件包存储的地方，通常我们所说的软件仓库指在线软件仓库，亦即用户从互联网获取软件的地方，选择一个国内的镜像源可以加速我们的下载过程。</p><blockquote><p>接下来的安装过程会用到Vim，如果没有接触过的话可以先看看一些<a href="https://coolshell.cn/articles/5426.html">教程</a>，掌握基本的操作。</p></blockquote><p>用Vim打开/etc/pacman.d/mirrorlist：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提示：输入路径时可以用Tab键补全</span></span><br><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>在normal模式下输入/可以进行查找，比如中科大的源，就可以查找ustc。normal模式下按下dd可以剪切光标下的行，按gg回到文件首，按p将行粘贴到文件最前面的位置（优先级最高）。完成后输入:wq保存退出即可。就像下面这样：<br><img src="/img/2019/11/11/8.jpg" class="lazy" data-srcset="/img/2019/11/11/8.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="source"></p><p>然后可以先刷新一下软件包数据库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Syy</span><br></pre></td></tr></table></figure><h3 id="安装基本包"><a href="#安装基本包" class="headerlink" title="安装基本包"></a>安装基本包</h3><p>使用pacstrap安装基本系统，目前base包已经被替换了，所以一些软件包需要手动安装，通常情况下有以下几个：</p><ul><li>一个软件元包base，包含基本系统所需的依赖</li><li>额外的软件包组比如base-devel，包含常用的开发工具</li><li>一个内核，大概有以下几种：<ul><li>linux : 当前的稳定版本内核</li><li>linux-lts : 当前的长期支持版本内核</li><li>linux-hardened : 来自 <a href="https://github.com/anthraxx/linux-hardened">https://github.com/anthraxx/linux-hardened</a> 的安全强化内核</li><li>linux-zen : 来自 <a href="https://github.com/zen-kernel">https://github.com/zen-kernel</a> 的预载一定量优化的内核</li></ul></li><li>大多数情况下，应该需要安装固件包 linux-firmware</li><li>一个文字编辑器，比如Vi、Vim、nano等</li><li>管理所用文件系统的用户工具，比如e2fsprogs、ntfs-3g，分别支持ext4和NTFS，如果还有其他需要，可以参考<a href="https://wiki.archlinux.org/index.php/File_systems">官方文档</a>的说明自行安装</li><li>要像刚才一样联网的话，还需要这些：dhcpcd netctl iw dialog wpa_supplicant networkmanager</li></ul><p>比如我的安装示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware vi vim e2fsprogs ntfs-3g dhcpcd netctl iw dialog wpa_supplicant networkmanager</span><br></pre></td></tr></table></figure><p>回车后就是等待安装完成了。</p><h3 id="配置Fstab"><a href="#配置Fstab" class="headerlink" title="配置Fstab"></a>配置Fstab</h3><blockquote><p>这fstab是干嘛用的呢？（简单来说就是自动挂载）</p><p>fstab文件可用于定义磁盘分区，各种其他块设备或远程文件系统应如何装入文件系统。每个文件系统在一个单独的行中描述。这些定义将在引导时动态地转换为系统挂载单元，并在系统管理器的配置重新加载时转换。 在启动需要挂载的服务之前，默认设置会自动fsck和挂载文件系统。例如，systemd会自动确保远程文件系统挂载 （如NFS或Samba）仅在网络设置完成后启动。因此，在/etc/fstab中指定的本地和远程文件系统挂载应该是开箱即用的。</p></blockquote><p>生成自动挂载分区的fstab文件，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genfstab -L /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><p>可以输出一下生成的文件来检查是否正确，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h3 id="Chroot"><a href="#Chroot" class="headerlink" title="Chroot"></a>Chroot</h3><p>Chroot意为Change root，相当于把操纵权交给我们新安装（或已经存在）的Linux系统，执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。如果以后我们的系统滚挂了，还需要用U盘启动，然后将根分区挂载到/mnt下，再使用chroot进系统修复，所以说U盘用完了不要扔哦~</p><p>Change root 到新安装的系统：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><h3 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置时区为上海并生成相关文件</span></span><br><span class="line"><span class="comment"># ln -s &lt;源文件&gt; &lt;目标&gt; 创建一个符号链接</span></span><br><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时间标准为UTC，并调整时间漂移:</span></span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><p>顺带说一下，如果是双系统的话，Win和Arch的时间会不一样，这是因为Windows会把硬件时钟认为是localtime，而Linux会认为是UTC时间，所以会有8个小时的时差，解决方法可以改Win，也可以改Linux，这里以Win为例，修改使其将硬件时钟认为是UTC时间即可（在早于 Windows 7 的系统上发现过这样做会出现一些严重的问题： <a href="http://www.cl.cam.ac.uk/~mgk25/mswish/ut-rtc.html">http://www.cl.cam.ac.uk/~mgk25/mswish/ut-rtc.html</a> ）。</p><p>使用注册表修改，可以将下面的命令输入到Power Shell（管理员模式）中执行，也可以新建一个后缀为.reg的注册表文件，将命令粘进去，右键执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1</span><br></pre></td></tr></table></figure><h3 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h3><p>设置使用的语言选项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>/etc/locale.gen 是一个仅包含注释文档的文本文件。指定需要的本地化类型，去掉对应行前面的注释符号（＃）就可以啦，用Vim打开就可以了，建议只选择带UTF-8的选项，比如：</p><ul><li>zh_CN.UTF-8 UTF-8</li><li>zh_HK.UTF-8 UTF-8</li><li>zh_TW.UTF-8 UTF-8</li><li>en_US.UTF-8 UTF-8</li></ul><p>执行 locale-gen 以生成 locale 讯息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure><p>创建 locale.conf 并提交本地化选项：</p><blockquote><p>将系统 locale 设置为en_US.UTF-8，系统的 Log 就会用英文显示，这样更容易问题的判断和处理。用户可以设置自己的 locale。不推荐在此设置任何中文locale，可能会导致tty乱码。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="设置一个你喜欢的主机名吧："><a href="#设置一个你喜欢的主机名吧：" class="headerlink" title="设置一个你喜欢的主机名吧："></a>设置一个你喜欢的主机名吧：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将myhostname改为你想要设置的主机名</span></span><br><span class="line"><span class="built_in">echo</span> myhostname &gt; /etc/hostname</span><br></pre></td></tr></table></figure><h4 id="添加对应的信息到-hosts"><a href="#添加对应的信息到-hosts" class="headerlink" title="添加对应的信息到 hosts:"></a>添加对应的信息到 hosts:</h4><p>编辑/etc/hosts文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>在文件末添加如下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">::1             localhost</span><br><span class="line">127.0.1.1myhostname.localdomainmyhostname</span><br></pre></td></tr></table></figure><h3 id="Root密码"><a href="#Root密码" class="headerlink" title="Root密码"></a>Root密码</h3><p>为你的root用户设置一个密码（虽然绝大多数时候是用不到的）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>回车之后直接输入密码就好了，屏幕上应该是啥都没有的，正常输入就完事了~</p><h3 id="设置sudo"><a href="#设置sudo" class="headerlink" title="设置sudo"></a>设置sudo</h3><p>因为 root 用户的权力很大而且很危险，所以轻易不会用到它。</p><p>所以就有了 sudo(substitute user do) 使得系统管理员可以授权特定用户或用户组作为 root 或其他用户执行某些（或所有）命令，同时还能够对命令及其参数提供审核跟踪。</p><p>sudo 应该已经作为 base-devel 的一部分装上去了，如果没有的话也可以自己手动安装一下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S sudo</span><br></pre></td></tr></table></figure><p>sudo 的配置文件是 /etc/sudoers，不过有一个方便的指令visudo可以帮我们代理编辑它（就是先编辑一个临时文件，然后检查有没有错误， 一切 OK 后再覆盖）。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>没错，其实就是用vi打开的，所以操作方式也和vi一样，找到下面这行，并将%wheel前面的注释符去掉，像下面这样：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Uncomment to allow members of group wheel to execute any command</span></span><br><span class="line">%wheel ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><h4 id="新建普通用户"><a href="#新建普通用户" class="headerlink" title="新建普通用户"></a>新建普通用户</h4><p>配置完sudo后也可以顺带设置一下我们平常使用的普通用户：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自行替换username为你的用户名</span></span><br><span class="line">useradd -m -G wheel username</span><br></pre></td></tr></table></figure><p>相关参数的解释可以看我的<a href="https://www.akaneym.com/posts/install-arch-on-windows/#%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7">上一篇</a>文章，这里就不再赘述了。<br>为你的新用户添加密码（这个密码是要经常用的）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自行替换username为你的用户名</span></span><br><span class="line">passwd username</span><br></pre></td></tr></table></figure><h3 id="安装Intel-ucode（非IntelCPU可以跳过此步骤）"><a href="#安装Intel-ucode（非IntelCPU可以跳过此步骤）" class="headerlink" title="安装Intel-ucode（非IntelCPU可以跳过此步骤）"></a>安装Intel-ucode（非IntelCPU可以跳过此步骤）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S intel-ucode</span><br></pre></td></tr></table></figure><h3 id="安装启动器"><a href="#安装启动器" class="headerlink" title="安装启动器"></a>安装启动器</h3><p>启动器就是加载我们操作系统的程序，它是 BIOS 或 UEFI 启动的第一个程序。它负责使用正确的内核参数加载内核, 并根据配置文件加载初始化 RAM disk。</p><p>如果对其它的启动管理器有兴趣的话，可以去看 <a href="https://wiki.archlinux.org/index.php/Arch_boot_process#Boot_loader">https://wiki.archlinux.org/index.php/Arch_boot_process#Boot_loader</a> 。</p><p>这里以Linux常用的GRUB为例：</p><ul><li><p>首先安装os-prober，它可以配合Grub检测已经存在的系统，自动设置启动选项。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S os-prober</span><br></pre></td></tr></table></figure></li><li><p>安装grub与efibootmgr两个包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S grub efibootmgr</span><br></pre></td></tr></table></figure></li><li><p>部署grub:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub</span><br></pre></td></tr></table></figure></li><li><p>生成配置文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>在生成配置文件的过程中，应该可以看到Windows的启动项，没看到的话需要进入Arch之后重新生成配置。</p></li><li><p>如果报 grub-probe: error: cannot find a GRUB drive for /dev/sdb1, check your device.map 的错误，并且sdb1这个地方是你的u盘，这是u盘uefi分区造成的错误，对安装没有影响，可以不用理会。</p></li><li><p>如果报 WARNING: Failed to connect to lvmetad. Falling back to device scanning 这样的错误，也可以不用理会，这是因为chroot中/run是不可用的。</p></li></ul><p>如果你不放心的话，也可以检查一下刚才生成的grub.cfg配置文件中有没有Windows的启动项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><p>一般在文件的末尾处可以找到，如果没有找到的话需要回头看一下哪里做错了，实在不行的话可以参考<a href="https://wiki.archlinux.org/index.php/GRUB/Tips_and_tricks#Combining_the_use_of_UUIDs_and_basic_scripting">这里</a>编辑配置文件手动添加引导的分区入口。</p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>先退出chroot:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>现在基本的安装已经结束了，可以尝试重启一下试试能不能正常启动，如果一切顺利的话就可以再次登陆安装我们的桌面环境了，再次登陆的时候可以使用新建的普通用户。</p><h1 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h1><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>建议先安装集显的驱动，如果有需要的话再装独显的。</p><ul><li><p>如果你是Intel的集成显卡，可以装这个：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xf86-video-intel</span><br></pre></td></tr></table></figure></li><li><p>如果是ATI/AMD的话，可以参照<a href="https://wiki.archlinux.org/index.php/ATI_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">官方文档</a>的说明安装相应的驱动（建议选闭源的驱动，性能相对来说会更好），我这里就懒得写了（逃</p></li><li><p>一种Intel + Nvidia显卡的解决方案：<br>在桌面环境安装完成后再尝试此选项，本来这部分应该放到后面的，但既然说到了显卡驱动，也就一并写上了~</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nvidia: 英伟达闭源驱动。如果使用自定义内核，那就安装nvidia-dkms</span></span><br><span class="line"><span class="comment"># bbswitch: 切换使用的节能工具。如果使用自定义内核，那就安装bbswitch-dkms</span></span><br><span class="line">sudo pacman -S nvidia bbswitch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 托盘程序（可视化切换及设置）。会自动安装核心程序</span></span><br><span class="line"><span class="comment"># 如果配置有archlinuxcn源，那么同样可以使用pacman来安装</span></span><br><span class="line"><span class="comment"># 如果使用KDE桌面，另有optimus-manager-qt-kde可供选择</span></span><br><span class="line">yay -S optimus-manager-qt</span><br></pre></td></tr></table></figure><p>安装完成后重启，应该就可以看到panel栏中的manager了，右键点击它，选择设置—Optimus，Switching method选择Bbswitch，确定保存。之后切换显卡就可以用右键方便地选择了。</p><p>更多详细内容可以去看原作者的README文档，项目地址<a href="https://github.com/Askannz/optimus-manager">这儿</a>。</p><h2 id="Xorg"><a href="#Xorg" class="headerlink" title="Xorg"></a>Xorg</h2><p>接下来安装桌面环境需要的基础包xorg</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S xorg</span><br></pre></td></tr></table></figure><h2 id="安装桌面环境"><a href="#安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h2><p>Linux下可选的桌面环境有很多，具体的可以去<a href="https://wiki.archlinux.org/index.php/Desktop_environment_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">官方文档</a>查看，这里就以常见的Gnome和KDE为例吧：</p><ul><li><p>GNOME</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 想要 GNOME 全家桶的话带上 gnome-extras</span></span><br><span class="line">sudo pacman -S gnome</span><br></pre></td></tr></table></figure></li><li><p>KDE</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接安装软件包组（包含了很多软件包）即可</span></span><br><span class="line">sudo pacman -S plasma kde-applications</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装桌面管理器"><a href="#安装桌面管理器" class="headerlink" title="安装桌面管理器"></a>安装桌面管理器</h2><p>安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，KDE建议配合sddm，GNOME建议用gdm。这里以sddm为例：</p><h3 id="安装sddm"><a href="#安装sddm" class="headerlink" title="安装sddm"></a>安装sddm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S sddm</span><br></pre></td></tr></table></figure><h3 id="设置开机启动sddm服务"><a href="#设置开机启动sddm服务" class="headerlink" title="设置开机启动sddm服务"></a>设置开机启动sddm服务</h3><p>Arch用于管理系统服务的命令为systemctl，使用方法也非常简单，大致如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start   服务名 （启动一项服务）</span><br><span class="line">sudo systemctl stop    服务名 （停止一项服务）</span><br><span class="line">sudo systemctl <span class="built_in">enable</span>  服务名 （开机启动一项服务）</span><br><span class="line">sudo systemctl <span class="built_in">disable</span> 服务名 （取消开机启动一项服务）</span><br></pre></td></tr></table></figure><p>所以这里我们就执行下面命令来设置开机启动sddm：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>由于我们之前使用的一直都是netctl这个自带的网络服务，而桌面环境使用的是NetworkManager这个网络服务，所以我们需要禁用netctl并启用NetworkManager：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">disable</span> netctl</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> NetworkManager</span><br></pre></td></tr></table></figure><h2 id="中文字体的安装"><a href="#中文字体的安装" class="headerlink" title="中文字体的安装"></a>中文字体的安装</h2><p>用pacman就可以方便的安装啦，选择你自己喜欢的字体吧：</p><ul><li><p>Google Noto Fonts 系列： noto-fonts noto-fonts-cjk noto-fonts-emoji</p></li><li><p>思源黑体：adobe-source-han-sans-otc-fonts</p></li><li><p>文泉驿：wqy-microhei wqy-zenhei</p></li></ul><p>更多字体可以在<a href="https://wiki.archlinux.org/index.php/Fonts_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">这里</a>找到。</p><p>现在就可以重启你的计算机了，再次登陆的时候应该就可以看到你安装好的桌面环境了。</p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><p>其实到这里所有的安装都已经完成了，接下来主要是一些个人常用的软件、配置项的记录（不定时更新），方便以后重装的时候配置，大家也可以酌情参考~</p><h2 id="ZSH"><a href="#ZSH" class="headerlink" title="ZSH"></a>ZSH</h2><p>具体内容<a href="https://www.akaneym.com/post/install-arch-on-windows/#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh">上一篇</a>有写，这里不再赘述。</p><h2 id="常用的命令行工具"><a href="#常用的命令行工具" class="headerlink" title="常用的命令行工具"></a>常用的命令行工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S neofetch git tree curl wget</span><br></pre></td></tr></table></figure><h2 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S ffmpeg</span><br></pre></td></tr></table></figure><h2 id="添加ArchLinuxCN"><a href="#添加ArchLinuxCN" class="headerlink" title="添加ArchLinuxCN"></a>添加ArchLinuxCN</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/pacman.conf</span><br></pre></td></tr></table></figure><p>在文件末尾添加以下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure><p>在安装archlinuxcn-keyring时可能会报本地秘钥无法签署的错误，这是因为pacman上游更新了密钥环的格式，这使得本地的主密钥无法签署其他密钥。解决方法如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以root身份运行</span></span><br><span class="line">su</span><br><span class="line">pacman -Syu haveged</span><br><span class="line">systemctl start haveged</span><br><span class="line">systemctl <span class="built_in">enable</span> haveged</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -fr /etc/pacman.d/gnupg</span><br><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate archlinux</span><br><span class="line">pacman-key --populate archlinuxcn</span><br></pre></td></tr></table></figure><p>完成后再次刷新一下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure><h2 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h2><p>之前一个好用的AUR助手yaourt已经停止更新了，现在建议使用yay代替它：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay.git</span><br><span class="line"><span class="built_in">cd</span> yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用yay -S xxx来下载软件了（注意前面不要加sudo）。<br>更新软件仓库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Syu</span><br></pre></td></tr></table></figure><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S google-chrome</span><br></pre></td></tr></table></figure><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S visual-studio-code-bin</span><br></pre></td></tr></table></figure><blockquote><p>Visual Studio Code使用DBus传递菜单，如果全局菜单失效，可以尝试安装 libdbusmenu-glib</p></blockquote><h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h2><p>这里推荐使用VLC和MPV：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S vlc mpv</span><br></pre></td></tr></table></figure><h2 id="截图软件"><a href="#截图软件" class="headerlink" title="截图软件"></a>截图软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S shutter</span><br></pre></td></tr></table></figure><h2 id="latte-dock"><a href="#latte-dock" class="headerlink" title="latte-dock"></a>latte-dock</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S latte-dock</span><br></pre></td></tr></table></figure><h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>命令行客户端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S shadowsocks</span><br></pre></td></tr></table></figure><p>Usage:</p><ul><li><p>使用ss-local 命令启动客户端<br>启动客户端时使用/etc/shadowsocks/config.json配置文件:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure></li><li><p>Shadowsocks的systemd服务可在/etc/shadowsocks/里调用不同的conf-file.json</p><p>例如，在/etc/shadowsocks/中创建了foo.json配置文件，那么执行以下语句就可以调用该配置：</p><ul><li>启动shadowsocks：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start shadowsocks@foo</span><br></pre></td></tr></table></figure></li><li>开机自启动shadowsocks：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> shadowsocks@foo</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>图形客户端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S shadowsocks-qt5</span><br></pre></td></tr></table></figure><h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S netease-cloud-music</span><br></pre></td></tr></table></figure><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>可用的有Ibus和Fcitx，这里以Fcitx为例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx fcitx-im</span><br></pre></td></tr></table></figure><p>然后在~/.xprofile文件（没有就新建一个）中加入以下几行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> XMODIFIERS=<span class="string">&quot;@im=fcitx&quot;</span></span><br></pre></td></tr></table></figure><p>重启后应该就能使用输入法了~</p><h2 id="blender"><a href="#blender" class="headerlink" title="blender"></a>blender</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S blender</span><br></pre></td></tr></table></figure><h2 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/pacman.conf</span><br><span class="line"><span class="comment"># 取消下面注释</span></span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装32位驱动</span></span><br><span class="line">sudo pacman -S lib32-nvidia-utils lib32-mesa-libgl lib32-mesa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装steam和必需的运行组件</span></span><br><span class="line">sudo pacman -S steam steam-native-runtime</span><br></pre></td></tr></table></figure><h2 id="Minecraft"><a href="#Minecraft" class="headerlink" title="Minecraft"></a>Minecraft</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S minecraft-launcher</span><br></pre></td></tr></table></figure><h1 id="E-N-D"><a href="#E-N-D" class="headerlink" title="E.N.D"></a>E.N.D</h1><p>至此Arch Linux已经全部安装完成了，赶紧开始你的Arch之旅吧~</p><p><em>Just Enjoy It</em></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://wiki.archlinux.org/index.php/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Installation guide</a><br><a href="https://wiki.archlinux.org/">Arch Wiki</a><br><a href="https://www.viseator.com/2017/05/17/arch_install/">以官方Wiki的方式安装ArchLinux</a><br><a href="https://blog.yoitsu.moe/arch-linux/installing_arch_linux_for_complete_newbies.html">给 GNU/Linux 萌新的 Arch Linux 安装指南 rev.B</a><br><a href="https://www.archlinuxcn.org/gnupg-2-1-and-the-pacman-keyring/">GnuPG-2.1 与 pacman 密钥环</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote class=&quot;blockquote-note blockquote-note__info&quot;&gt;&lt;div class=&quot;blockquote-note__header&quot;&gt;&lt;div class=&quot;blockquote-note__icon&quot;&gt;&lt;svg xmlns</summary>
      
    
    
    
    <category term="笔记本" scheme="https://akaneym.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="Arch Linux" scheme="https://akaneym.com/tags/Arch-Linux/"/>
    
    <category term="安装指南" scheme="https://akaneym.com/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>scp下载服务器文件</title>
    <link href="https://akaneym.com/posts/usage-of-scp/"/>
    <id>https://akaneym.com/posts/usage-of-scp/</id>
    <published>2019-11-02T10:46:00.000Z</published>
    <updated>2022-11-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-note blockquote-note__info"><div class="blockquote-note__header"><div class="blockquote-note__icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></div>Note</div><div class="blockquote-note__content"><p>更推荐使用 rsync 替代 scp。</p></div></blockquote><p>一个平常的晚上，突然心血来潮想试试 Blender 2.80 的 eevee，遂去官网看了下，没想到正式版都出来了，但下载安装包的时候却出现了极其蛋疼的问题：</p><p><img src="/img/2019/11/02/1.png" class="lazy" data-srcset="/img/2019/11/02/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="下载速度感人"></p><p>这显然是难以忍受的，正好我有一台洛杉矶的服务器，于是便打算利用它来下载，然后传回本地电脑上。相关的工具也很多，比如 xftp、scp、ftp 等，今天就记录一下 scp 的使用方法。</p><h1 id="什么是-scp"><a href="#什么是-scp" class="headerlink" title="什么是 scp"></a>什么是 scp</h1><p>scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。和它类似的命令有 cp，不过 cp 只是在本机进行拷贝不能跨服务器，而且 scp 传输是加密的，可能会稍微影响一下速度。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><blockquote><p>若ssh端口不是默认的22，可以加上-P port参数（注意-P为大写）</p></blockquote><h2 id="上传本地文件到服务器"><a href="#上传本地文件到服务器" class="headerlink" title="上传本地文件到服务器"></a>上传本地文件到服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /path/filename username@servername:/path/</span><br></pre></td></tr></table></figure><h2 id="从服务器上下载文件"><a href="#从服务器上下载文件" class="headerlink" title="从服务器上下载文件"></a>从服务器上下载文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp username@servername:/path/filename /local_dir</span><br></pre></td></tr></table></figure><h2 id="从服务器下载整个目录"><a href="#从服务器下载整个目录" class="headerlink" title="从服务器下载整个目录"></a>从服务器下载整个目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r username@servername:/remote_dir /local_dir</span><br></pre></td></tr></table></figure><h2 id="上传目录到服务器"><a href="#上传目录到服务器" class="headerlink" title="上传目录到服务器"></a>上传目录到服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure><h1 id="E-N-D"><a href="#E-N-D" class="headerlink" title="E.N.D"></a>E.N.D</h1><p>小忍姐姐真是太帅了~</p><p><em>さようなら</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote class=&quot;blockquote-note blockquote-note__info&quot;&gt;&lt;div class=&quot;blockquote-note__header&quot;&gt;&lt;div class=&quot;blockquote-note__icon&quot;&gt;&lt;svg xmlns</summary>
      
    
    
    
    <category term="笔记本" scheme="https://akaneym.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="scp" scheme="https://akaneym.com/tags/scp/"/>
    
    <category term="服务器" scheme="https://akaneym.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>WSL安装记</title>
    <link href="https://akaneym.com/posts/install-arch-on-windows/"/>
    <id>https://akaneym.com/posts/install-arch-on-windows/</id>
    <published>2019-10-21T10:59:00.000Z</published>
    <updated>2019-10-21T10:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>Windows一直以来的一大痛点就是没有一个好用的命令行环境。此前虽然一直有听说 WSL ，但当时我还是用的多系统，所以并没有太多关注。在经过Windows -&gt; Ubuntu -&gt; Arch Linux -&gt; 黑苹果 -&gt; Windows的轮回后，我终于又用回了Windows 10(真香)。而作为 Linux 最好的发行版(雾)，怎么能没有一个好用的命令行环境呢？！虽然一直有折腾一下的想法，但<del>平时课实在是太多了啊</del>(其实是我太懒了(o´ω`o)ﾉ)于是就这样一直拖到了现在，今天正好有两节实验课比较水，完成任务后就开始了捣鼓，顺便<del>记录一下过程</del>(氵博客)。</p><h2 id="关于WSL"><a href="#关于WSL" class="headerlink" title="关于WSL"></a>关于WSL</h2><p>Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。相较于虚拟机更为轻巧方便，安装也比较简单，开启WSL后在微软商店中直接搜索即可安装。</p><h1 id="安装前的配置"><a href="#安装前的配置" class="headerlink" title="安装前的配置"></a>安装前的配置</h1><h2 id="启用WSL"><a href="#启用WSL" class="headerlink" title="启用WSL"></a>启用WSL</h2><p>控制面板-&gt;程序和功能-&gt;启用或关闭 window 功能-&gt;勾选“适用于 Linux 的 Windows 子系统”，之后重启系统。<br><img src="/img/2019/10/21/1.png" class="lazy" data-srcset="/img/2019/10/21/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="启用WSL"></p><h2 id="打开开发者模式"><a href="#打开开发者模式" class="headerlink" title="打开开发者模式"></a>打开开发者模式</h2><p>设置-&gt;更新与安全-&gt;开发者选项-&gt;开发者模式<br><img src="/img/2019/10/21/2.png" class="lazy" data-srcset="/img/2019/10/21/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="选择开发者模式"></p><h2 id="安装所需要的发行版"><a href="#安装所需要的发行版" class="headerlink" title="安装所需要的发行版"></a>安装所需要的发行版</h2><p>在微软商店搜索你需要安装的发行版，点击安装即可。我这里用的是Arch Linux，官方商店中并没有提供镜像，有以下两种方法解决：</p><ul><li><p>使用非官方的安装包</p><p>arch可以在github找到非官方的安装包，安装过程非常简单，下载完成后运行安装程序即可，仓库地址在<a href="https://github.com/yuk7/ArchWSL">这儿</a><br><img src="/img/2019/10/21/3.png" class="lazy" data-srcset="/img/2019/10/21/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="Arch的安装文件"></p></li><li><p>安装微软商店中的Ubuntu，按照Arch Wiki上的操作将内核换成Arch</p><p>这里步骤比较多，我也并没有用这种方法，所以就懒得写了，地址我放在<a href="https://wiki.archlinux.org/index.php/Install_on_WSL_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">这儿</a>了，大家有兴趣的话自己去看吧（逃~</p></li></ul><h1 id="安装完成后的配置"><a href="#安装完成后的配置" class="headerlink" title="安装完成后的配置"></a>安装完成后的配置</h1><blockquote><p>第一次安装程序时可能会报错，提示没有合法的数字签名。运行以下两条命令即可：</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化 pacman 秘钥</span></span><br><span class="line">pacman-key --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证主密钥</span></span><br><span class="line">pacman-key --populate</span><br></pre></td></tr></table></figure><h2 id="安装VIM"><a href="#安装VIM" class="headerlink" title="安装VIM"></a>安装VIM</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S vim</span><br></pre></td></tr></table></figure><h2 id="配置国内的-mirrorlist-源"><a href="#配置国内的-mirrorlist-源" class="headerlink" title="配置国内的 mirrorlist 源"></a>配置国内的 mirrorlist 源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>这里以清华的源为例，删掉开头的注释符”#”使其生效（之前在实体机上安装的时候这些源都是未被注释的，即都生效，优先选择最上面的源，所以只需要将你需要的源放到第一个就行了，WSL这边似乎有些不一样，如果有知道的大佬可以解答一下~）<br><img src="/img/2019/10/21/4.png" class="lazy" data-srcset="/img/2019/10/21/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="更换源"></p><p>保存关闭后使用下面的命令刷新软件列表并更新软件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure><h2 id="添加新的普通用户"><a href="#添加新的普通用户" class="headerlink" title="添加新的普通用户"></a>添加新的普通用户</h2><blockquote><p>注意：我之后的操作步骤都是在root身份下完成的，貌似windows terminal在非root环境下会有bug，反正我是用不了Tab补全，Ctrl +C清屏等功能的，不知道后续会不会修复，大家酌情选择吧~</p></blockquote><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -G wheel username</span><br></pre></td></tr></table></figure><p>username 替换为你的用户名</p><p>各参数的含义：</p><p>-m：在创建时同时在/home目录下创建一个与用户名同名的文件夹，这个目录就是你的家目录。这个神奇的目录将会用于存放你所有的个人资料、配置文件等所有跟系统本身无关的资料。这种设定带来了诸多优点：</p><ul><li>只要家目录不变，你重装系统后只需要重新安装一下软件包（它们一般不存放在家目录），然后所有的配置都会从家目录中读取，完全不用重新设置软件。</li><li>你可以在家目录不变的情况下更换你的发行版而不用重新配置你的环境。</li><li>切换用户后所有的设置会从新的用户的家目录中读取，将不同用户的资料与软件设置等完全隔离。</li><li>有些著名的配置文件比如vim的配置文件~/.vimrc，只要根据自己的使用习惯配置一次， 在另一个Linux系统下（例如你的服务器）把这个文件复制到家目录下，就可以完全恢复你的配置。</li></ul><p>-G wheel：-G代表把用户加入一个组，wheel就是组名，加入这个组是为了方便使用sudo命令。</p><h3 id="为root和新用户设置密码"><a href="#为root和新用户设置密码" class="headerlink" title="为root和新用户设置密码"></a>为root和新用户设置密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root</span></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment"># other user</span></span><br><span class="line">passwd username</span><br></pre></td></tr></table></figure><h3 id="配置sudo"><a href="#配置sudo" class="headerlink" title="配置sudo"></a>配置sudo</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>找到 # %wheel ALL=(ALL)ALL 这一行，取消前面的注释符“#”。</p><p>这里的%wheel就是代表wheel组，意味着wheel组中的所有用户都可以使用sudo命令。</p><blockquote><p>root切换到普通用户可以使用 su - username 命令</p></blockquote><h2 id="安装配置zsh"><a href="#安装配置zsh" class="headerlink" title="安装配置zsh"></a>安装配置zsh</h2><p>虽然一般情况下默认的bash已经够用了，但是zsh更为强大高效，如果没有用过的话强烈推荐体验一下~</p><h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到用户文件夹</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装zsh及必要的软件</span></span><br><span class="line">pacman -S wget curl git</span><br><span class="line">pacman -S zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载oh-my-zsh,用于美化zsh，不注重这些的话可以不装</span></span><br><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋予安装脚本可执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x install.sh</span><br><span class="line"></span><br><span class="line">./install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改系统默认的shell</span></span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>首先了解几个重要的文件：</p><ul><li>zsh的配置文件 ： ~/.zshrc</li><li>主题的存放路径 ： ~/.oh-my-zsh/themes</li><li>插件的存放路径： ~/.oh-my-zsh/plugins</li></ul><p>更改主题只需要在.zshrc文件中更改即可:<br><img src="/img/2019/10/21/5.png" class="lazy" data-srcset="/img/2019/10/21/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="更改主题"><br>更改完成后要使其立即生效只需执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>配色根据自己用的terminal来改吧，我这里用的是windows terminal，配置文件有需要的话可以参考：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;$schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;defaultProfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows PowerShell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.85</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#777777&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;closeOnExit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Night Owlish Light&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Monaco&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;powershell.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorShape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filledBox&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;scrollbarState&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hidden&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.85</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;closeOnExit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Night Owlish Light&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Monaco&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorShape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filledBox&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;scrollbarState&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hidden&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Azure Cloud Shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows.Terminal.Azure&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.85</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;closeOnExit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Night Owlish Light&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Monaco&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorShape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filledBox&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;scrollbarState&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hidden&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;a5a97cb8-8961-5535-816d-772efe0c6a3f&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Arch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows.Terminal.Wsl&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.85</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#777777&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;closeOnExit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Night Owlish Light&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Monaco&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E://Arch//archlinux.png&quot;</span><span class="punctuation">,</span> <span class="comment">// 换上你自己图标的路径</span></span><br><span class="line">            <span class="attr">&quot;scrollbarState&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hidden&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;schemes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;black&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#011627&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;blue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#4876D6&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightBlack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#7A8181&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightBlue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#5CA7E4&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightCyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#00C990&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightGreen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#49D0C5&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightPurple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#697098&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightRed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F76E6E&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightWhite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#989FB1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;brightYellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#DAC26B&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#08916A&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#403F53&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;green&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#2AA298&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Night Owlish Light&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;purple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#403F53&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;red&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#D3423E&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;white&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#7A8181&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;yellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#DAAA01&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;keybindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>更多配色可以去<a href="https://iterm2colorschemes.com/">这里</a>找，更多关于Windows Terminal的配置项可以阅读<a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md">官方文档</a></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>下面介绍几个我正在用的zsh插件：</p><h4 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h4><p>自动补全插件，作用是记录下你曾经输入过的命令，之后再次输入时就会有类似IDE自动补全的效果，非常好用，安装方法可以直接用git clone：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><h4 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h4><p>语法高亮插件，能自动识别输入的命令是否有效，有效会显示成绿色，无效为红色：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>安装完成后修改一下.zshrc文件，使插件生效：<br><img src="/img/2019/10/21/6.png" class="lazy" data-srcset="/img/2019/10/21/6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="应用插件"></p><p>同样的，保存退出后使配置文件生效：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><hr><h1 id="E-N-D"><a href="#E-N-D" class="headerlink" title="E.N.D"></a>E.N.D</h1><p>到这里差不多基本的配置就完成了，今天就先写到这儿吧，有什么问题欢迎留言，最后放一张成果图吧~<br><img src="/img/2019/10/21/7.png" class="lazy" data-srcset="/img/2019/10/21/7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="Arch on Windows"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.viseator.com/2017/05/19/arch_setup/">ArchLinux安装后的必须配置与图形界面安装教程</a><br><a href="https://www.jianshu.com/p/a298e1c7b043">win10 arch子系统 docker</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;Windows一直以来的一大痛点就是没有一个好用的命令行环境。此前虽然一直有听说 WSL ，但当时我还是用的多系统，所以并没有太多关注。在经</summary>
      
    
    
    
    <category term="笔记本" scheme="https://akaneym.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="WSL" scheme="https://akaneym.com/tags/WSL/"/>
    
    <category term="Arch Linux" scheme="https://akaneym.com/tags/Arch-Linux/"/>
    
  </entry>
  
</feed>
